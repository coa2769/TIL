# HTTP 헤더 개요

첫번째 섹션은 일반적으로 사용되는 헤더들에 대해 설명해 두었다.

[ 1999년 RFC2616 ]

- General 헤더 : 메시지 전체에 적용되는 정보
- Request 헤더 : 요청 정보
- Response 헤더 : 응답 정보
- Entity 헤더 : 엔티티 바디 정보, 엔티티 본문의 데이터를 어떻게 해설할지 에 대한 정보가 담겨있다.

--------------- 2014년에 새로운 표준이 나오면서 이전 표전 폐기 --------------------------------------

[ 2014년 RFC7230 ~ RFC7235 ]

- 엔티티(Entity) -> 표현(Representation) 으로 변경됨
- Representation = representation Metadata + Representation Data
- 표현 = 표현 메타데이터 + 표현 데이터
- 표현은 요청이나 응답에서 전달할 실제 데이터
- 표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공
  - 데이터 유형, 데이터 길이, 압축 정보 등등



!!! 왜 표현이라고 하는가?

- 받을 수 있는 데이터는 HTML, JSON등 여러 방법으로 표현되어 전달된다.
- 그래서 단어를 명확하게 변경함.



# 표현

- 서버에 저장된 리소스는 굉장히 추상적이다. (DB의 데이터 일수도 있고 파일 일수도 있고...)
- 이를 서버와 클라이언트 간에 이해할 수 있는 데이터로 표현하여 전송해줘야한다.
- 이때 사용되는 헤더가 '표현'이다.
  - Content-Type : 표현 데이터의 형식
    - 미디어 타입, 문자 인코딩
  - Content-Encoding : 표현 데이터의 압축 방식
    - 데이터 전달하는 곳에서 압출 후 인코딩 헤더 추가
    - 데이터를 읽는 쪽에서 압축해제를 하기 위한 정보
    - ex) gzip, deflate, identity(압출 안함)
  - Content-Language : 표현 데이터의 자연 언어
    - ex) ko, en, en-US
  - Content-Length : 표현 데이터의 길이
    - 바이트 답위
    - Transfer-encoding(전송 코딩)을 사용하면 해당 속성을 써서는 안된다.(추후에 이유 설명)
- 전송, 응답 둘다 사용.



# 콘텐츠 협상

- 클라이언트가 선호하는 표현들을 서버에 요청한다.

- 서버는 클라이언트의 선호도를 방영하여 데이터를 표현하여 응답을 보낸다.

- 이때 필요한 Header이다.

  - Accept : 클라이언트가 선호하는 미디어 타입 전달

  - Accept-Charset : 클라이언트가 선호하는 문자 인코딩

  - Accept-Encoding : 클라이언트가 선호하는 압축 인코딩

  - Accept-Language : 클라이언트가 선호하는 자연언어



- 협상 헤더는 요청시에만 사용

- 서버가 모든 요청을 꼭 맞춰줄 필요는 없다.

- Accept-Language 예제

  - 적용 전
  - 적용 후

- 선호하는 표현에 우선순위를 줄 수 있다.

  - quality values(q)

    - 0~1 클수록 높은 우선순위
    - 생략하면 1

  - 구체적인 것이 우선한다.

    - ex) Accept : text/*, text/plain, text/plain;format=flowed, \*/\* 
    - text/plain;format=flowed > text/plain > text/* > \*/\* 로 우선순위가 정해짐.

  - 구체적인 것을 기준으로 미디어 타입을 맞춘다.

    - Accept : text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, \*/\*;q=0.5

      -  text/*는 text/plain으로 미디어타입이 맞춰진다.(서버에서 구체적인 미디어 타입으로 맞춰서 해석한다.)

      - 이렇게 까지는 사용하지 않는다.

      - 좀더 자세한 설명

        ```text
        text/html;leavel=1에 대해 서버가 지원할 수 있는 것을 딱 맞다고 표현하신 것 같습니다.
        
        즉, 서버가 요청 헤더의 accept 값을 살펴보는데 text/html;level=1(q=1)이 있었고 마침 서버가 해당 미디어타입을 지원한다면 그걸로 응답을 주는 것입니다. 그리고 text/html;level=1의 퀄리티가 1이기 때문에 미디어타입 중 우선순위가 가장 높으며 서버는 우선순위가 높은 순서대로 응답할 수 있는 것을 찾아서 응답을 제공합니다.
        ```

        

      



# 전송 방식

## 전송 방식 설명

- 단순 전송
  - Content-Length에 작성된 길이에 맞게 데이터 전송
  - 요청한 데이터를 한번에 받음
- 압축 전송
  - 서버에서 압축이 이루어진 데이터 전송
  - Content-Encoding 헤더가 추가됨.
- 분할 전송
  - Transfer-Encoding : chunked 헤더가 추가된다.
  - 큰 덩어리를 쪼개서 보낸다.
    - 쪼개진 데이터(chumked마다)의 Byte크기와 데이터가 전송된다.
    - 쪼개어 보낸데이터의 마지막에는 `0 \r\n`이 보낸다.
  - Content-Length를 보내서는 안된다. (예상이 안되서)
- 범위 전송
  - 특정 범위의 데이터를 요청할 때 사용한다.
  - Content-Range 헤더가 추가된다.
  - 응답에 문제가 생겼을 때 특정 범위의 데이터를 다시 받으려고 할때 사용한다.



# 일반 정보

단순한 정보성 Header

- Form : 유저 에이전트의 이메일 정보
  - 일반적으로 잘 사용되지 않음
  - 검색 엔진 같은 곳에서, 주로 사용
  - 요청에서 사용함
- Referer : 이전 웹 페이지 주소
  - 현재 요청된 페이지의 이전 웹페이지 주소
  - 해당 웹 페이지로 유입된 경로를 분석할 수 있다.
- User-Agent : 유저 에이전트 애플리케이션 정보
  - 클라이언트의 애플리케이션 정보
  - 특정 브라우저에서 장애가 생기는 것을 파악할 때 유용하다.
- Server : 요청을 처리하는 오리진 서버의 소프트웨어 정보
  - 중간에서 캐싱해주는 프록시 서버가 아닌 실제 내 요청을 처리해주는 서버의 정보
  - 응답에서 사용
- Date : 메시지가 생성된 날짜
  - 메시지가 발생한 날짜와 시간
  - 응답에서 사용(과거에는 요청에서도 가능했지만 최신 스펙에서는 응답에서만)



# 특별한 정보

실제 애플리케이션에 영향을 주는 정보들.

- Host : 요청한 호스트 정보(도메인)
  - 필수 헤더!!
  - 요청에서 사용
  - 하나의 서버가 여러 도메인을 처리해야 할 때 
  - 하나의 IP 주소에 여러 도메인이 적용되어 있을 때 
  - 하나의 서버에서 각각의 도메인으로 서비스를 지원하는 상황이 있을 수 있다.
    - 이런 것을 하나의 서버가 여러 도메인을 처리할 때 or 하나의 IP주소에 여러 도메인이 적용되어 있을 때의 상황이다.
  - 이때 해당 요청이 어느 도메인과 매칭된 서비스의 요청인지 구분하기 위해 해당 정보를 사용한다.
- Location : 페이지 리다이렉션
  - 리다이렉션 또는 생성된 리소스의 URI를 전달할 때 사용한다.
  - 201상태 코드와 3xx 상태코드와 연관이 있다.
- Allow : 허용 가능한 HTTP 메서드
  - 서버가 허용하지 않는 메서드로 HTTP 요청이 왔을 때 이를 알려주기 위해 사용
  - 405 (Method Not Allowed)에서 응답에 포함됨.
- Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
  - 서비스가 언제까지 이용 불가인지 알리 때
  - 503 상태코드와 연관있다.



# 인증

- Authorization : 클라이언트 인증 정보를 서버에 전달
  - 인증 메커니즘마다 들어가는 정보가 다르다(oauth 등등)
  - 어느 인증 메커니즘이든 상관없이 해당 헤더는 요청에 들어간다.
- WWW-Authenticate : 리소스 접근시 필요한 인증 방법 정의
  - 401 응답과 함께 보낸다.



# 쿠키

[ 쿠키 미사용  예시 ]

서버 입장에서 로그인한 사용자인지 구분할 방법이 없는 예제

- HTTP는 무상태(Stateless) 프로토콜이다.
- 클라이언트와 서버가 요청과 응답을 주고 받으면 연결이 끊어진다.
- 서버가 클라이언트의 이전 요청을 기억하지 못한다.
- 클라이언트와 서버는 서로 상태를 유지하지 않는다.

[ 모든 요청에 사용자 정보 포함한 예시 ]

- 보안과 개발에 힘듬.
- 브라우저를 완전히 종료하고 다시 연면 어떻게 되는가?



!! 이런 문제를 해결하기 위해 Cookie를 사용

[ 쿠키를 이용한 예시 ]

- 로그인 후 서버에서 Set-Cookie로 로그인한 유저에 대한 정보가 온다.
  - 서버에 생성되어 저장된 세션 키를 보내온다.(직접적인 유저 정보가 아니라.)
- 클라이언트는 이를 쿠키 저장소에 저장 후 요청을 보낼때 마다 Cookie헤더에 추가하여 보낸다.



- Set-Cookie : 서버에서 클라이언트로 쿠키 전달(응답)
- Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달



쿠키 저장소에 저장된 정보는 요청을 보낼때 마다 데이터를 전송한다. 

- 네트워크 트래픽 추가 유발
- 최소한의 정보만 사용(세션 id, 인증 토큰)

요청때 마다 전송하지 않고 웹브라우저 내부에 저장했다가 필요할 때 JS로직에서만 사용하고 싶다면 웹 스토리지(localStorage, sessionStorage)를 이용하면된다. (필요할때 JS에서 요청을 보낼때 추가해서 보내면 된다.)



### 쿠키 - 생명주기

- Set-Cookie : **expires** =......
  - 만료일이 되면 쿠키 삭제
- Set-Cookie : **max-age**=....
  - 0이나 음수를 지정하면 쿠키 삭제
- 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시 까지만 유지
- 영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지



### 쿠키 - 도메인

- 쿠키는 도메인에 따라 분류되어 저장할 수 있습니다.

- 도메인을 명시 했을 때

  - 명시된 기준 도메인과 서브 도메인에서 해당 쿠키를 접근 할 수 있다. 

    ex) example.org(기준 도메인) , dev.example.org(서브 도메인) 에서 모두 접근 가능.

    - 여기서 접근은 요청을 보낼때 전송한다는 뜻이다.

- 도메인을 생략 했을 때

  - 현재 문서 기준 도메인에서만 접근 가능하다.

    ex) example.org에서만 접근 가능, dev.example.org에서 쿠기 미접근

### 쿠키 - 경로

- 이 경로를 포함한 하위 경로 페이지만 쿠키 접근

- 일반적으로 path=/ 루트로 지정

  ​	ex)

  ​		path=/home 지정

  ​		/home -> 가능

  ​		/home/level1 -> 가능

  ​		/home/level1/level2 -> 가능

  ​		/hello -> 불가능

### 쿠키 - 보안

- Secure
  - https인 경우에만 쿠키를 전송하게 된다.
- HttpOnly
  - XSS 공격 방지
  - JS에서 접근 불가
  - HTTP 전송에만 사용
- SameSite
  - XSRF 공격 방지
  - 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송 허용
  - 지원한지 얼마되지 않아 브라우저 스펙을 확인해야 한다.









