# 캐시 기본 동작

### 캐시가 없을 때

- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야한다.
- 인터넷 네트워크는 매우 느리고 비싸다.
- 브라우저 로딩 속도가 느려지는 원인이 된다.
- 느린 사용자 경험

- 예시 이미지



### 캐시 적용

- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
- 비싼 네트워크 사용량을 줄일 수 있다.
- 브라우저 로딩 속도가 매우 빠르다.
- 빠른 사용자 경험

- 작동 순서

  1. 처음으로 데이터를 서버에서 가져올 때 응답 헤더에 캐시가 유효한 시간이 추가되어 온다.

  2. 브라우저 캐시에서 데이터가 60초 동안 유지된다.

     2.1. 60이내에 다시 같은 데이터를 로드한다면 브라우저 캐시에서 데이터를 가져온다.

     2.2. 캐시의 유효시간이 지났다면 다시 데이터를 서버에서 가져온다.

     ​	2.2.1. 가져온 데이터를 다시 브라우저 캐시에 업데이트 한다.



### 캐시 시간 초과

- 서버를 통해 데이터를 다시 조회하고 캐시를 갱신해야 한다.
- 이때 다시 네트워크 다운로드가 발생



하지만 캐시 시간은 초과되었지만 서버에서 데이터가 전혀 변경되지 않는 상황도 발생할 수 있다.

이때 사용하는 것이 검증 헤더와 조건부 요청이다.

# 검증 헤더와 조건부 요청1

### 검증 헤더

- Last-Modified : 해당 데이터가 마지막에 수정된 날짜

### 조건부 요청

- if-modified-since : 데이터를 요청을 보낼 때 캐싱된 데이터의 최종 수정일을 같이 보낼 때 사용한다.

### 검증 헤더와 조건부 요청을 사용한 캐시 작동 순서

1. 요청에 데이터를 보냄

   - 이때 Last-Modified를 응답으로 데이터를 보낼 때 헤더에 추가하여 보낸다.

2. 받은 데이터를 브라우저 캐시에 저장

3. 브라우저 캐시에 저장된 데이터가 캐시 시간을 초과하였다.

4. 브라우저 캐시에 저장된 데이터 다시 요청 보낸다.

   4.1. Last-Modified가 있다면 요청헤더에  if-modified-since(조건부 요청)를 붙여서 보낸다.

5. 서버에서 if-modified-since로 브라우저에 캐싱된 데이터와 서버의 데이터가 다른지 판별
6. 304 Not Modified 상태 코드로 응답을 보내서 캐시를 그대로 사용해도 된다고 브라우저에 알린다.(HTTP Body가 없음)



### 정리

- 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운 로드 도니다.
- 매우 실용적인 해결책



# 검증 헤더와 조건부 요청2

### 검증 헤더

- 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
- Last-Modified, ETag

### 조건 부 요청 헤더

- 검증 헤더로 조건에 따른 분기
- if-Modified-Since 이후에 데이터가 수정 되었는지 물어보는 헤더 필드
  - Last-Modified와 함께 이용된다.
  - 데이터 미변경 예시
    - 304  Not Modified
  - 데이터 변경 예시
    - 200 OK
  - 단점
    - 1초 미만 단위 캐시 조정 불가능
    - 데이터 수정 날짜는 다르지만 같은 데이터를 수정하여 결과가 똑같은 경우
    - 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 
- if-None-Match
  - if-Modified-Since에서 단점들을 해결하기 위해 사용하는 것들.
  - ETag 와 함께 상요된다.
    - 캐시용 데이터에 임의의 고유한 버전 이름을 달아주는 검증 헤더
    - ex) ETag : "v1.0", ETag : "a2jiodwjekjl3"
  - 데이터 변경되면 ETag로 보낸 이름을 바꾸어서 변경함(Hash 다시 생성)
    - ex) ETag : "aaaaa" -> ETag : "bbbbb"
  - 진짜 단순하게 ETag만 보내서 같은면 유지, 다르면 다시 받기! (이 부분은 if-Modified-Since이랑 같음)



### ETag, If-None-Match 정리

- 캐시 제어 로직을 서버에서 완전히 관리
- 클라이언트는 단순히 ETag로 받은 값을 서버에 제공





# 캐시와 조건부 요청 헤더

### 캐시 제어와 연관된 헤더

- Cache-Control : 캐시 제어
  - 아래의 내용들은 키=값 형태로 Cache-Control 헤더에 작성하여 캐시를 제어할 수 있다.
  - max-age : 캐시 유효 시간, 초 단위
  - no-cache : 데이터는 캐시해도 되지만 항상 원(origin) 서버에 검증하고 사용
    - 중간에 있는 프록시 캐시 서버가 아닌 origin 서버에서 검증
  - no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨 (메모리에서 사용하고 최대한 빨리 삭제)
- Pragma : 캐시 제어(하위 호완)
  - HTTP 1.0 하위 호환
  - 지금은 거의 사용하지 않음
- Expires : 캐시 유효 기간 (하위 호환)
  - 캐시 만료일을 정확한 날짜로 지정
  - HTTP 1.0부터 사용
  - 지금은 더 유연한 Cache-Control : max-age를 권장한다.
  - Cache-Control: max-age와 같은 사용하면 Expires는 무시된다.

- Pragma와 Expires는 하위 버전 HTTP 호한을 위한 것으로 현재는 Cache-Control로 모두 제어 가능하다.



### 검증 헤더와 조건부 요청 헤더

- 검증 헤더(Validator)
  - ETag : "v1.0", ETag : "asid93jkrh2l"
  - Last-Modified : Thu, 04 Jun 2020 07:19:24 GMT
- 조건부 요청 헤더
  - If-Match, If-None-Match -> ETag 값 사용
  - If-Modified-Since, If-Unmodified-Since -> LastModified 값 사용



# 프록시 캐시

이런 프록시 캐시 서버 서비스를 CDS 서비스라고 한다.

- 클라이언트에 가까운 곳에 프록시 캐시 서버들이 배치되어 있다.
- 웹 브라우저는 데이터를 가져올 때 가까운 곳에 있는 프록시 캐시 서버를 먼저 들린다.
- 브라우저 내에 있는 캐시를 private 캐시
- 프록시 캐시 서버에 있는 캐시를 public 캐시라고 한다. (공용 캐시)



### Cache-Control 캐시 지시어(directives) - 기타

- Cache-Contro : public
  - 응답이 public 캐시에 저장되어도 됨
- Cach-Control : private
  - 응답이 해당 사용자만을 위한 것임.
  - private 캐시에 저장해야 함(기본값)
- Cache-Contro: s-maxage
  - 프록시 캐시에만 적용되는 max-age
  - 특별한 상황에서 사용하는 것으로 알아만 두자!!!
- Age: 60 (HTTP 헤더)
  - 오리진 서버에서 응답 후 프록시 캐시 내에 캐시가 머물 수 있는 시간(초)
  - 특별한 상황에서 사용하는 것으로 알아만 두자!!!



# 캐시 무효화

### 확실하게 캐시를 무효화하는 응답

- 캐시 적용을 안해도 웹브라우저가 임의로 캐시를 하기도한다.(GET 요청의 경우)
- 아래의 내용을 모든 응답에 추가하면 해당 페이지는 캐시가 되지 않는다.
  - Cache-Control : no-cache, no-store, must-revalidate
  - Pragma: no-cache (HTTP 1.0 하위 호환을 위한 내용)



### 사용된 캐시 지시어 들

- Cache-Control : no-cache
  - 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용
- Cache-Control: no-store
  - 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)
- Cach-Control : must-revalidate
  - 캐시 만료후 최초 조회시 원 서버에 검증해야함
  - 원 서버 접근 실패시 반드시 오류가 발생해야함 - 504 (Gateway Timeout)
  - must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
- Pragma: no-cache
  - HTTP 1.0 하위 호환



### no-cache 기본 동작

- 만약 프록시 캐시 서버와 원 서버 간의 네트워크 단절로 접근 불가가 된다면 
  - Error or 200 OK로 웹 브라우저에 응답해야한다.
  - 이때 프록시 캐시 서버는 오류 보다는 오래도니 데이터라도 보여주려는 설정이 있을 때가 있다.
  - 이러면 no-cache 설정이 무효화 된다.

### must-revalidate 

- must-revalidate는 원 서버에 접근할 수 없을 경우 항상 오류를 반환한다.
  - 504 Gateway Timeout 

- 이 때문에 no-cache 무효화를 must-revalidate가 막아 줄 수 있다.

  



