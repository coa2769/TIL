# 09월 17일
> 이전 '전문가 과정' 교육때 공부한 내용 정리
> '프론트 엔드 면접 질문'에 대한 대답 작성
> JS, Node.js 공부 내용 정리

## **컴퓨터가 계산 하는 방법**

1. 덧셈 하는 방법

1.1. 반가산기

- 논리회로를 조합
- 1bit 덧셈 연산을 한다.
- A가 1, B가 1이면 XOR 연산결과 S(SUM 합)는 0 , AND 연산결과 C(Carry 올림)는 1

1.2. 전가산기

- 하위의 자리올림수 입력을 포함하여 결과를 출력한다.
- 이 가산기를 여럿 이으면 큰 숫자도 덧셈이 가능하다.
- 32bit 덧셈 계산기를 만들면 32bit CPU가 된다.

2. 뺄셈 하는 방법

[ 보수 ]

- 2의 보수 → 어떤 숫자에 뭘 더해야 2가 되는 가?
- 10의 보수 → 어떤 숫자에 뭘 더해야 10이 되는 가?
- 1의 보수 → 어떤 숫자에 뭘 더해야 1이 되는 가?

2.1. 보수로 뺄셈하는 방법

컴퓨터는 2의 보수(Complement)를 더해서 '뺄셈' 한다.

- 2진수에서 0은 1이 보수이며 1은 0이 보수이다.
- 1의 보수에 1을 더했을 때 2의 보수가 된다.
- 어떤 숫자에 2의보수를 더하면 자동으로 2진수 뺄셈이 된다. 단, 자리올림은 버린다.

[ 예시 ]

13 - 6 = 7

- 4는 6에 대한 10의 보수이다.
- 13에 6에 대한 10의 보수 4를 더하고 10자리에서 1을 빼면 7이 된다.

3. 곱셈 하는 방법

- 같은 수를 여러 번 더하며 곱셈이 된다.
7 x 2 = 7 + 7,  3 x 3 = 3 + 3 + 3
- 왼쪽으로 Shift 연산을 하면 곱셈이 된다. (짝수 곱셈)
- 왼쪽으로 한 칸 밀면 곱하기 2, 두 칸 밀면 곱하기 4
- 여러번 더하기와 왼쪽 Shift 두 방법을 혼합한다.
- "어떻게 조합해서 쓰는가?"는 최적화와 구현 방법과 연관있다.


4. 나눗셈 하는 방법

- 나눔 당하는 숫자를 나누는 숫자로 여러 번 빼면 나눗셈이다.
9 / 3 → 9 - 3 - 3 - 3  → 값 : 3
5 / 3 → 5 - 3 → 값 : 1.... 나머지 : 2
    - 이때 0을 계속 빼게 되면 0보다 작은 숫자가 나올수 없으므로 무한에 빠지게 된다. (주의)
- 오른쪽으로 Shift 연산을 하면 나눗셈이 된다. (짝수 나눗셈)
- 오른쪽으로 한 칸 밀면 나누기2, 두 칸 밀면 나누기 4
- 여러번 빼기와 오른쪽 Shift 두 방법을 혼합한다.
- "어떻게 조합해서 쓰는가?"는 최적화와 구현 방법과 연관있다.

---
## **기술면접 질문 대답**
**5. 다음이 IIFE로 작동하지 않는 이유를 성명하세요 : function foo(){}();를 IIFE로 만들기 위해서는 무엇을 바꿔야하나요?**

**즉시 실행 함수 표현(IIFE, Immediately Invoked Function Expression)**

두 부분으로 구성된다. 

첫번째는 괄호()로 둘러싸인 익명함수(Anonymous Function)이다.

- 전역 스코프에 불필요한 변수를 추가해서 오염 시키는 것을 방지.
- IIFE 내분안으로 다른 변수들의 접근을 막을 수 있다.

두번째는 즉시 실행 함수를 생성하는 괄호() 이다.

```jsx
(function () {
	statements
})();
```

IIFE는 즉시 함수 호출 표현식을 의미 합니다. JS parser는 function foo{}();을 fucntion foo(){}인 함수 선언과 ();인 함수 호출로 읽어들입니다. 이때 후자에서 호출되는 함수의 식별자가 없는 것으로 인식되어 Uncaught SyntaxError : Unexpected token )가 발생된다.

이를 해결하는 방법은 두 가지가 있다.

- 함수 선언을 ()로 묶으면 함수 식이 되어 ()로 함수를 호출할 수 있다.

    ```jsx
    (function(){
    	statements
    })();

    과 

    (function(){
    	statements
    }() )
    ```

- void 연사자를 사용할 수도 있다.

    ```jsx
    void function foo(){
    	statements
    }();
    ```

    - 이러한 방법에서 함수는 언제나 undefined만을반환할 수 있다.

    ```jsx
    //문자열을 반환할 수 없다.
    const foo = void (function bar(){
    	return 'foo';
    })();

    console.log(foo); //undefined
    ```

**6. null, undefined, undeclared의 차이점은 무엇인가요? 어떻게 이 상태들에 대한 확인을 할 것인가요?**

**undeclared 변수**

: var, let, const로 정의 되지 않은 식별자에 값을 할당할 때 생성됩니다.

- 현재 범위 외부에 전역으로 정의 ##추후 추가조사
- strict 모드에서 할당하려고 하면 ReferenceError가 발생한다.
- linter를 사용하면 이런 경우가 있는지 확인할 수 있다.

```jsx
function foo(){
	x = 1;
}

foo();
console.log(x);
```

**undefined 변수**

: 선언되었지만, 값이 할당되지 않은 변수

- 함수가 실행 결과에 아무값도 반환하지 않으면 변수에 undefined가 할당된다.
- 이를 검사하는 방법.
    - 엄격한(===) 연산자
    - typeof에 undefined문자열을 사용하여 비교

```jsx
var foo;
console.log(foo); //undefined
console.log(foo === undefined); //true
console.log(typeof foo === 'undefined'); //true

console.log(foo == null); //true. null과 같다는 결과가 나오므로 주의!!

function bar() {}
var baz = bar();
console.log(baz); //undefined
```

**null 변수**

: null 값이 명시적으로 할당된 변수. 

- null 은 값을 나타내지 않음을 나타낸다.
- 엄격한(===) 연산자로 검사한다.

```jsx
var foo = null;
console.log(foo === null); //true

console.log(foo == undefined); //true. undefined과 같다는 결과가 나오므로 주위!!
```

변수를 선언하지 않거나(undeclared) 할당하지 않은 상태(unassigned)로 두지 않아야 한다. 

아직 값을 할당하지 않는 변수라면 null을 할당한다.


**8. .forEach루프와 .map() 루프 사이의 주요 차이점을 설명할 수 있나요? 왜 둘 중 하나를 선택할 것인가요?**

**forEach**

- 배열의 요소 반복.
- 각 요소에 대해 콜백을 실행합니다.
- 값을 반환하지 않습니다.

```jsx
const a = [1, 2, 3];
const doubled = a.forEach((num, index) => {
	//num나 index로 무언가 합니다.
});

//doubled = undefined
```

**map**

- 배열의 요소 반복.
- 각 요소에 함수를 호출하여 결과로 새 배열의 요소들을 구성한다.

```jsx
const a = [1, 2, 3];
const doubled = a.map((num) =>{
	return num * 2;
});

//doubled = undefined
```

.map()은 새로운 배열을 반환한다. 원본 배열의 변경없이 결과가 필요하다면 .map을 선택하고 단순히 배열을 반복할 필요가 있다면 forEach가 좋습니다.

**9. 익명 함수의 일반적인 사용 사례는 무엇인가요?**

익명함수는 IIFE로 구현되어 지역 범위 내에서 일부 코드를 캡슐화하고 선언된 변수가 전역 범위로 누출되지 않습니다.

```jsx
(fucntion() {
	//코드
}) ();
```

- 한 번만 사용되어 다른 곳에서 사용될 필요 없는 콜백에서 사용된다.

    ```jsx
    setTimeout(function() {
    	console.log('Hello World!');
    }, 1000);
    ```

- 함수형 프로그래밍
- Lodash에 대한 인수(콜백과 유사)로 사용된다.

    ```jsx
    const arr = [1, 2, 3];
    const double = arr.map(funciton(el){
    	return el * 2;
    });

    console.log(double);
    ```

**lodash란?**

- JavaScript 유틸리티 라이브러리
- array, collection, date, number, object 등의 데이터를 쉽게 다룰 수 있도록 도와준다.
- 특히 JS에서 배열 안의 객체들의 값을 핸들링할때 유용하다.


**11. 호스트 객체와 내장 객체의 차이점은 무엇인가요?**

**내장 객체**는 ECMAScript 사양에 정의된 **JS언어의 일부**인 객체입니다. 

**예시)** String, Math, RegExp, Object, Function 등

**호스트 객체**는 Window, XMLHTTPRequest 등과 같이 **런타임 환경(브라우저 or 노드)**에 의해 제공됩니다.



---

## Node.js
1. 핵심 개념

1.1. 서버

- 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램.

1.2. 자바스크립트 런타임

- 런타임 : 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻함.
- 노드는 자바스크립트 프로그램을 컴퓨터에 실행할 수 있다.
- 노드는 V8과 libuv 라이브러리를 사용한다.
- libuv 라이브러리는 노드의 특성인 이벤트 기반, 논 블로킹 I/O 모델을 구현하고 있다.


1.3. 이벤트 기반

- 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식.
- 이벤트를 등록한다. = 이벤트 리스터에 콜백 함수를 등록 한다.
- 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지 이벤트 루프가 판단
- 이벤트 루프 : 이벤트 발생 시 호출할 콜백 함수 관리, 실행 순서 결정.
- 백그라운드 : setTimeout같은 타이머나 이벤트 리스터들이 대기하는 곳. 여러 작업이 동시에 실행 될 수 있음.
- 태스크 큐(=콜백 큐) : 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보낸다. 콜백은 보통 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀌기도 한다.

```jsx
[ 예시 ]
function fun(){
	console.log('3초 후 실행');
}

console.log('시작');
setTimeout(fun, 3000);
console.log('끝);
```

[ 이벤트 루프는 호출 스택이 비어 있을 때만 태스크 큐에 있는 run함수를 호출 스택으로 가져오므로 setTimeout의 시작이 정확하지 않을 수 있다.]

1.4. 논 블로킹 I/O

- I/O : 입력, 출력을 의미한다. ex) 파일 시스템 접근, 네트워크 요청
- 논 블로킹 : 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것.
- 노드는 논 블로킹 방식으로 I/O를 처리하는 방법을 제공한다.
- 논 블로킹와 동시는 같은 의미가 아니다.
    - 동시성은 동시 처리가 가능한 작업을 논 블로킹 처리해야 얻을 수 있다.

1.5. 싱글 스레드

- 프로세스는 운영체제에서 할당하는 작업의 단위. 프로세스간에는 메모리 등의 자원을 공유하지 않음.
- 스레드는 프로세스 내에서 실행되는 흐름의 단위. 여러 개 생성하여 여러 박업을 동시에 처리할 수 있음. 부모 프로세스의 자원 공유.
- 노드는 여러 스레드를 생성하지만 그 중에서 사용자가 직접 제어할 수 있는 스레드는 하나뿐이다.
- 노드가 싱글 스레드로 동작하지 않을 때.
    - 암호화, 파일 입출력, 압출 등에서 스레드 풀을 이용한다.
    - 노드 12버전 부터 워커 스레드로 멀티 스레드를 안정적으로 구현 할 수 있게 되었다.
- I/O 처리 시 노드는 효율이 높은 멀티 프로세싱을 많이 한다. (서버로 구현할 때 네트워크 통신에서 특히, 이에 관련된 패키지도 있다.)

2. 서버로서의 노드

2.1. 장점

- 멀티 스레드 방식에 비해 적은 컴퓨터 자원 사용
- I/O 작업이 많은 서버로 적합
- 멀티 스레드 방식보다 구현이 쉬움
- 웹 서버가 내장되어 있음
- 개발에 자바스크립트를 사용함
- JSON형식과 쉽게 호환됨

2.2. 단점

- 기본적으로 싱글 스레드이므로 CPU 코어 하나만 사용
- CPU작업이 많은 서버에 부적합
- 하나뿐인 스레드가 멈추지 않도록 관리가 필요
- 서버 규모가 커녔을 때 서버를 관리하기 어려움
- 어중간한 성능